diff --git a/sound/soc/sunxi/sun4i-i2s.c b/sound/soc/sunxi/sun4i-i2s.c
index cd43f6c2d3e5..0865666af04b 100644
--- a/sound/soc/sunxi/sun4i-i2s.c
+++ b/sound/soc/sunxi/sun4i-i2s.c
@@ -27,6 +27,7 @@
 #define SUN4I_I2S_CTRL_MODE_MASK		BIT(5)
 #define SUN4I_I2S_CTRL_MODE_SLAVE			(1 << 5)
 #define SUN4I_I2S_CTRL_MODE_MASTER			(0 << 5)
+#define SUN4I_I2S_CTRL_LOOP			BIT(3)
 #define SUN4I_I2S_CTRL_TX_EN			BIT(2)
 #define SUN4I_I2S_CTRL_RX_EN			BIT(1)
 #define SUN4I_I2S_CTRL_GL_EN			BIT(0)
@@ -212,6 +213,8 @@ struct sun4i_i2s {
 	struct regmap_field	*field_fmt_sr;
 
 	const struct sun4i_i2s_quirks	*variant;
+
+	bool loopback;
 };
 
 struct sun4i_i2s_clk_div {
@@ -279,9 +282,11 @@ static int sun4i_i2s_get_bclk_div(struct sun4i_i2s *i2s,
 	int div = parent_rate / sampling_rate / word_size / channels;
 	int i;
 
+	printk("%s COOPS word size %d parent rate %d sampling rate %d channels %d mclk is %d\n", __func__, word_size ,parent_rate, sampling_rate, channels, i2s->mclk_freq);
 	for (i = 0; i < i2s->variant->num_bclk_dividers; i++) {
 		const struct sun4i_i2s_clk_div *bdiv = &dividers[i];
 
+		printk("%s COOPS bdiv %d div is %d\n", __func__, bdiv->div, div);
 		if (bdiv->div == div)
 			return bdiv->val;
 	}
@@ -297,9 +302,11 @@ static int sun4i_i2s_get_mclk_div(struct sun4i_i2s *i2s,
 	int div = parent_rate / mclk_rate;
 	int i;
 
+	printk("%s COOPS parent rate %d mclk rate is %d\n", __func__, parent_rate ,mclk_rate);
 	for (i = 0; i < i2s->variant->num_mclk_dividers; i++) {
 		const struct sun4i_i2s_clk_div *mdiv = &dividers[i];
 
+		printk("%s COOPS mdiv %d div is %d\n", __func__, mdiv->div, div);
 		if (mdiv->div == div)
 			return mdiv->val;
 	}
@@ -312,9 +319,11 @@ static bool sun4i_i2s_oversample_is_valid(unsigned int oversample)
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_oversample_rates); i++)
+	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_oversample_rates); i++) {
+		printk("%s COOPS i%d is %d looking for %d\n", __func__, i, sun4i_i2s_oversample_rates[i], oversample);
 		if (sun4i_i2s_oversample_rates[i] == oversample)
 			return true;
+	}
 
 	return false;
 }
@@ -689,6 +698,10 @@ static int sun4i_i2s_hw_params(struct snd_pcm_substream *substream,
 	u32 width;
 	int lines;
 
+	printk("COOPS %s channels is %d, physical width is %d, rate is %d, period size is %d\n",
+		__func__, params_channels(params), params_physical_width(params),
+		params_rate(params), params_period_size(params));
+
 	if (i2s->slots)
 		slots = i2s->slots;
 
@@ -1008,6 +1021,20 @@ static int sun4i_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 			   SUN4I_I2S_FIFO_CTRL_RX_MODE(1));
 
 	i2s->format = fmt;
+	{
+	/* COOPS DEBUGGING FOR NOW */
+	u32 reg_val = 0;
+
+	printk("COOPS %s fmt value is 0x%x. Setting the following registers.\n", __func__, fmt);
+	regmap_read(i2s->regmap, SUN4I_I2S_CTRL_REG, &reg_val);
+	printk("SUN4I_I2S_CTRL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FMT0_REG, &reg_val);
+	printk("SUN4I_I2S_FMT0_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FIFO_CTRL_REG, &reg_val);
+	printk("SUN4I_I2S_FIFO_CTRL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN8I_I2S_TX_CHAN_SEL_REG, &reg_val);
+	printk("SUN8I_I2S_TX_CHAN_SEL_REG 0x%x\n", reg_val);
+	}
 
 	return 0;
 }
@@ -1031,6 +1058,11 @@ static void sun4i_i2s_start_capture(struct sun4i_i2s *i2s)
 	regmap_update_bits(i2s->regmap, SUN4I_I2S_DMA_INT_CTRL_REG,
 			   SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN,
 			   SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN);
+
+	/* Debugging without codec */
+	if (i2s->loopback)
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
+				   SUN4I_I2S_CTRL_LOOP, SUN4I_I2S_CTRL_LOOP);
 }
 
 static void sun4i_i2s_start_playback(struct sun4i_i2s *i2s)
@@ -1107,6 +1139,34 @@ static int sun4i_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 	default:
 		return -EINVAL;
 	}
+	{
+	/* COOPS DEBUGGING FOR NOW */
+	u32 reg_val = 0;
+
+	printk("I2S Command State %d\n", cmd);
+	regmap_read(i2s->regmap, SUN4I_I2S_CTRL_REG, &reg_val);
+	printk("SUN4I_I2S_CTRL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FMT0_REG, &reg_val);
+	printk("SUN4I_I2S_FMT0_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FMT1_REG, &reg_val);
+	printk("SUN4I_I2S_FMT1_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FIFO_CTRL_REG, &reg_val);
+	printk("SUN4I_I2S_FIFO_CTRL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_CLK_DIV_REG, &reg_val);
+	printk("SUN4I_I2S_CLK_DIV_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FIFO_STA_REG, &reg_val);
+	printk("SUN4I_I2S_FIFO_STA_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_TX_CHAN_SEL_REG, &reg_val);
+	printk("SUN4I_I2S_TX_CHAN_SEL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_TX_CHAN_MAP_REG, &reg_val);
+	printk("SUN4I_I2S_TX_CHAN_MAP_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN8I_I2S_TX_CHAN_MAP_REG, &reg_val);
+	printk("SUN8I_I2S_TX_CHAN_MAP_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN8I_I2S_RX_CHAN_SEL_REG, &reg_val);
+	printk("SUN8I_I2S_RX_CHAN_SEL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN8I_I2S_RX_CHAN_MAP_REG, &reg_val);
+	printk("SUN8I_I2S_RX_CHAN_MAP_REG 0x%x\n", reg_val);
+	}
 
 	return 0;
 }
@@ -1116,6 +1176,8 @@ static int sun4i_i2s_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 {
 	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
 
+	printk("COOPS %s clk id %d freq %d dir %d\n", __func__, clk_id, freq, dir);
+
 	if (clk_id != 0)
 		return -EINVAL;
 
@@ -1627,6 +1689,10 @@ static int sun4i_i2s_probe(struct platform_device *pdev)
 	i2s->capture_dma_data.addr = res->start + SUN4I_I2S_FIFO_RX_REG;
 	i2s->capture_dma_data.maxburst = 8;
 
+
+	if (of_property_read_bool(pdev->dev.of_node, "loopback"))
+		i2s->loopback = true;
+
 	pm_runtime_enable(&pdev->dev);
 	if (!pm_runtime_enabled(&pdev->dev)) {
 		ret = sun4i_i2s_runtime_resume(&pdev->dev);
