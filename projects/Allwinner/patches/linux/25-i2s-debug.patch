diff --git a/sound/soc/sunxi/sun4i-i2s.c b/sound/soc/sunxi/sun4i-i2s.c
index ecfc1ed79379..5dd4c6a2e57b 100644
--- a/sound/soc/sunxi/sun4i-i2s.c
+++ b/sound/soc/sunxi/sun4i-i2s.c
@@ -214,6 +214,8 @@ struct sun4i_i2s {
 	unsigned int	tdm_slots;
 	unsigned int	slot_width;
 	unsigned int	offset;
+
+	bool loopback;
 };
 
 struct sun4i_i2s_clk_div {
@@ -269,7 +271,9 @@ static int sun4i_i2s_get_bclk_div(struct sun4i_i2s *i2s,
 	int div = oversample_rate / word_size / 2;
 	int i;
 
+	printk("%s COOPS word size %d oversample_rate %d mclk is %d\n", __func__, word_size ,oversample_rate, i2s->mclk_freq);
 	for (i = 0; i < size; i++) {
+		printk("%s COOPS bdiv %d div is %d\n", __func__, bdiv->div, div);
 		if (bdiv->div == div)
 			return bdiv->val;
 		bdiv++;
@@ -288,7 +292,9 @@ static int sun4i_i2s_get_mclk_div(struct sun4i_i2s *i2s,
 	int div = module_rate / sampling_rate / oversample_rate;
 	int i;
 
+	printk("%s COOPS module rate %d sampling rate is %d oversample_rate %d\n", __func__, module_rate ,sampling_rate ,oversample_rate);
 	for (i = 0; i < size; i++) {
+		printk("%s COOPS mdiv %d div is %d\n", __func__, mdiv->div, div);
 		if (mdiv->div == div)
 			return mdiv->val;
 		mdiv++;
@@ -302,9 +308,11 @@ static bool sun4i_i2s_oversample_is_valid(unsigned int oversample)
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_oversample_rates); i++)
+	for (i = 0; i < ARRAY_SIZE(sun4i_i2s_oversample_rates); i++) {
+		printk("%s COOPS i%d is %d looking for %d\n", __func__, i, sun4i_i2s_oversample_rates[i], oversample);
 		if (sun4i_i2s_oversample_rates[i] == oversample)
 			return true;
+	}
 
 	return false;
 }
@@ -616,6 +624,10 @@ static int sun4i_i2s_hw_params(struct snd_pcm_substream *substream,
 	u32 width;
 	int lines;
 
+	printk("COOPS %s channels is %d, physical width is %d, rate is %d, period size is %d\n",
+		__func__, params_channels(params), params_physical_width(params),
+		params_rate(params), params_period_size(params));
+
 	channels = params_channels(params);
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		if ((channels > dai->driver->playback.channels_max) ||
@@ -850,6 +862,7 @@ static int sun4i_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 				SUN8I_I2S_CTRL_LRCK_OUT;
 			break;
 		case SND_SOC_DAIFMT_CBM_CFM:
+			printk("COOPS SUN4I_I2S_CTRL_REG IS SLAVE\n");
 			/* BCLK and LRCLK slave */
 			val = 0;
 			break;
@@ -870,6 +883,22 @@ static int sun4i_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 			   SUN4I_I2S_FIFO_CTRL_RX_MODE_MASK,
 			   SUN4I_I2S_FIFO_CTRL_TX_MODE(1) |
 			   SUN4I_I2S_FIFO_CTRL_RX_MODE(1));
+
+	{
+	/* COOPS DEBUGGING FOR NOW */
+	u32 reg_val = 0;
+
+	printk("COOPS %s fmt value is 0x%x. Setting the following registers.\n", __func__, fmt);
+	regmap_read(i2s->regmap, SUN4I_I2S_CTRL_REG, &reg_val);
+	printk("SUN4I_I2S_CTRL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FMT0_REG, &reg_val);
+	printk("SUN4I_I2S_FMT0_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FIFO_CTRL_REG, &reg_val);
+	printk("SUN4I_I2S_FIFO_CTRL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN8I_I2S_TX_CHAN_SEL_REG, &reg_val);
+	printk("SUN8I_I2S_TX_CHAN_SEL_REG 0x%x\n", reg_val);
+	}
+
 	return 0;
 }
 
@@ -894,6 +923,11 @@ static void sun4i_i2s_start_capture(struct sun4i_i2s *i2s)
 	regmap_update_bits(i2s->regmap, SUN4I_I2S_DMA_INT_CTRL_REG,
 			   SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN,
 			   SUN4I_I2S_DMA_INT_CTRL_RX_DRQ_EN);
+
+	/* Debugging without codec */
+	if (i2s->loopback)
+		regmap_update_bits(i2s->regmap, SUN4I_I2S_CTRL_REG,
+				   SUN4I_I2S_CTRL_LOOP, SUN4I_I2S_CTRL_LOOP);
 }
 
 static void sun4i_i2s_start_playback(struct sun4i_i2s *i2s)
@@ -972,6 +1006,34 @@ static int sun4i_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 	default:
 		return -EINVAL;
 	}
+	{
+	/* COOPS DEBUGGING FOR NOW */
+	u32 reg_val = 0;
+
+	printk("I2S Command State %d\n", cmd);
+	regmap_read(i2s->regmap, SUN4I_I2S_CTRL_REG, &reg_val);
+	printk("SUN4I_I2S_CTRL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FMT0_REG, &reg_val);
+	printk("SUN4I_I2S_FMT0_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FMT1_REG, &reg_val);
+	printk("SUN4I_I2S_FMT1_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FIFO_CTRL_REG, &reg_val);
+	printk("SUN4I_I2S_FIFO_CTRL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_CLK_DIV_REG, &reg_val);
+	printk("SUN4I_I2S_CLK_DIV_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_FIFO_STA_REG, &reg_val);
+	printk("SUN4I_I2S_FIFO_STA_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_TX_CHAN_SEL_REG, &reg_val);
+	printk("SUN4I_I2S_TX_CHAN_SEL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN4I_I2S_TX_CHAN_MAP_REG, &reg_val);
+	printk("SUN4I_I2S_TX_CHAN_MAP_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN8I_I2S_TX_CHAN_MAP_REG, &reg_val);
+	printk("SUN8I_I2S_TX_CHAN_MAP_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN8I_I2S_RX_CHAN_SEL_REG, &reg_val);
+	printk("SUN8I_I2S_RX_CHAN_SEL_REG 0x%x\n", reg_val);
+	regmap_read(i2s->regmap, SUN8I_I2S_RX_CHAN_MAP_REG, &reg_val);
+	printk("SUN8I_I2S_RX_CHAN_MAP_REG 0x%x\n", reg_val);
+	}
 
 	return 0;
 }
@@ -981,6 +1043,8 @@ static int sun4i_i2s_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 {
 	struct sun4i_i2s *i2s = snd_soc_dai_get_drvdata(dai);
 
+	printk("COOPS %s clk id %d freq %d dir %d\n", __func__, clk_id, freq, dir);
+
 	if (clk_id != 0)
 		return -EINVAL;
 
@@ -1513,10 +1577,14 @@ static int sun4i_i2s_probe(struct platform_device *pdev)
 
 	if (!of_property_read_u32(pdev->dev.of_node,
 				  "allwinner,playback-channels", &val)) {
+		dev_err(&pdev->dev, "Max playback channels changed from %d to %d\n", soc_dai->playback.channels_max, val);
 		if (val >= 2 && val <= 8)
 			soc_dai->playback.channels_max = val;
 	}
 
+	if (of_property_read_bool(pdev->dev.of_node, "loopback"))
+		i2s->loopback = true;
+
 	pm_runtime_enable(&pdev->dev);
 	if (!pm_runtime_enabled(&pdev->dev)) {
 		ret = sun4i_i2s_runtime_resume(&pdev->dev);
